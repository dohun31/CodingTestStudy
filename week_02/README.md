# 2주차

> - stack
> - queue
> - list

---

## 21.07.12 - stack

> - [4949 - 균형잡힌 세상](https://www.acmicpc.net/problem/4949)
> - [2504 - 괄호의 값](https://www.acmicpc.net/problem/2504)

`<4949>`

여는 괄호가 나오면 stack에 insert하고,
닫는 괄호가 나오면 쌍이 있는지 확인만 해주면 되는 문제여서 쉽게 풀었음

제출하는데 틀렸다고해서 봤더니 yes or no로 출력해야 하는걸 YES of NO로 출력해놔서 다시 고쳐서 제출하니까 맞음

`<2504>`

1. sum과 누적값 변수를 만들어서 0으로 초기화함.  
   stack이 비었을 때 누적값 > 0 이라면 sum += 누적값 \* (2 or 3), 누적값 = 0.  
   stack이 비었을 떄 누적값 == 0 이라면 sum += (2 or 3).  
   stack이 안비었을 떄 누적값 += (2 or 3)

이렇게 할 경우에 (()[[]])와 같이 () + [[]] 의 경우는 계산 오류가 남.

2. 여는 괄호일 때 sum[-1]이 0이 아니라면 sum에 0을 push해 줌.  
   괄호 한 쌍이 나오고.  
   sum[-1]이 0이면 sum[-1] += (2 or 3).  
   sum[-1]이 !0이면 sum[-1] \*= (2 or 3).

이렇게 할 경우에 더 복잡해짐

3. 닫는 괄호일때 stack[-1]이 정수라면 싹다 더하고 한쌍 만들어지면 \*(2 or 3)하고 push.  
   ex) (()) -> ['(', 2] 인 상태에서 )가 들어오면 stack[-1]이 정수이므로 2 \* 2 가 stack에 남게됨.  
   따라서 마지막에 stack에 정수들만 남는다면 모두 더한 값을 출력, 아니라면 0 출력.

생각보다 시간이 오래걸렸음

---

## 21.07.13 - stack

> - [5397 - 키로거](https://www.acmicpc.net/problem/5397)
> - [1918 - 후위표기식](https://www.acmicpc.net/problem/1918)
> - [17298 - 오큰수](https://www.acmicpc.net/problem/17298)

`<5397>`

처음에 문제보고 list.insert(index, value), pop(index) 이용해서 풀었는데 시간 복잡도가 너무 커져서 계속 시간 초과.
그래서 슬라이싱 이용해서 풀었는데도 계속 시간 초과…

그래서 구글링 해서 찾은 방법

- left stack, right_stack을 두고 왔다갔다 -> 신선한 충격…

문제보면 조금 더 생각해보기

`<1918>`

이 문제는 다 풀어 놓고 출력을 이상하게 해서 계속 틀렸음
join으로 출력을 했었는데 그냥 마음 편하게 while문 돌면서 pop하니까 해결... 허무해라

`<17298>`

어떻게 풀지는 다 생각했는데 그걸 구현을 못한 그런... 구글링하니까 방법은 똑같은데 되게 코드를 잘 짜셨길래 보고 다시 풀었다

---

## 21.07.14 - queue

> - [1158 - 요세푸스 문제](https://www.acmicpc.net/problem/5397)
> - [2161 - 카드1](https://www.acmicpc.net/problem/2161)

`<1158>`

5분정도 고민해보니까 큐로 어떻게 풀지 생각이 나서 바로 시작.

1. 일단 큐에 1 ~ N 까지 다 push함
2. 변수 i를 두고 k개를 계속 체크
3. while 문에서 큐가 빌 때 까지 i를 증가시키면서 pop한다. 이떄 i == K일 떄만 pop하고 i는 다시 1로 초기화함

풀다가 잠시 막힌 부분이 있었는데

- N이 K보다 작을때

  > - 처음에는 queue의 크기가 k보다 작으면 그냥 순서대로 pop하라고 했는데 생각해보니까 반례들이 너무 많았다. -> 첫 시도에서 틀림
  > - 그래서 시간이 너무 오래걸리지 않을까? 고민은 했지만 방법이 딱히 기억이 안나서 그냥 while문으로 계속 돌렸다. -> 역시나 시간 초과
  > - 고민하다가 pypy3로 제출하니까 시간안에 성공! pypy3.. 감사 ~

- 출력
  > - 출력을 <1, 2, 3> 형태로 요구해서 아래 처럼 하려고 했는데 숫자 사이에 ', '도 있고 마지막 숫자는 또 공백이 없고 좀 까다로웠음.
  ```python
  print('<')
  # pop한 값들을 result에 담아놨음
  while result:
     print(result.pop())
  print('>')
  ```
  > - 그래서 내가 좋아하는 join을 쓰기로 함
  ```python
  print('<' + ', '.join(result) + '>')
  ```

`<2161>`

문제를 읽어봤더니 그냥 간단한 구현 문제여서 쉽게 풀었음

---

## 21.07.15 - queue

> - [1966 - 프린터 큐](https://www.acmicpc.net/problem/1966)

`<1966>`

시간제한 2초를 보고 마음을 놨다. 요즘 제일 신경쓰는게 시간제한...

queue를 하나 두고 입력된 정보를 담는다.
이 때 queue에 [data, index]형태로 담음

입력된 정보도 sort해 둔다.

1. queue에서 한 개 pop함.
2. index가 target이랑 같고 data가 max값이라면 result출력
3. index가 target이랑 같지 않을 때, data가 max값이라면 max값을 pop함. 아니라면 다시 queue에 push함.

한 번에 성공!
그런데 더 효율적인 코드가 있어서 구글링하면서 공부중.
그리고 듣고 싶었던 강의 결제해서 오늘은 한개만 풀었다~~!

---

## 21.07.16 - list, queue

> - [1406 - 에디터](https://www.acmicpc.net/problem/1406)
> - [기능 개발](https://programmers.co.kr/learn/courses/30/lessons/42586)

`<1406>`

7월 13일에 풀었던 키로거 문제랑 비슷한 유형이어서 바로 그때 봤던 멋진 풀이 적용했다~~
진짜 cool한 코드..

그리고 원래라면 이렇게 썼는데

```python
if left_list:
   right_list.append(left_list.pop())
```

if 말고도 and or 연산자 잘 쓰고 싶어서

```python
left_list and right_list.append(left_list.pop())
```

and연산자 사용해서 코드를 짰다.

`<기능 개발>`

앞선 기능이 완성되어야 뒤의 기능도 배포를 할 수 있다
그래서 현재 진도와, 진행 속도로 배포까지 며칠 걸리는지 계산해서 큐에 차례대로 push했다.
이 때 며칠 걸리는지 계산은 아래와 같이 계산했다.

```python
import math
day = math.ceil((100 - progress) / speed)
```

day = [7, 3, 9]라면 큐를 사용해서 먼저 7을 pop하고 7보다 큰 숫자가 나올 때 까지 pop하고 개수를 count한다. 이런식으로 큐가 빌 때까지 반복하면 답이 나온다.

처음 시도에서 테스트 케이스 몇 개가 틀려서 황당했는데 알고봤더니 여기가 문제였다..!!

```python
if now_data > queue[0]:
   result[-1] += 1
   queue.popleft()
```

배포까지 걸리는 날이 같을 경우에 대해서 생각을 못했다.
한 글자 더 추가하니까 성공~~

```python
if now_data >= queue[0]:
   result[-1] += 1
   queue.popleft()
```

---

## 21.07.17 - stack

> - [10799 - 쇠막대기](https://www.acmicpc.net/problem/10799)
> - [2493 - 탑](https://www.acmicpc.net/problem/2493)

`<10799>`

처음 접근은 ((())) 이런식이면 ((1))로 만들고 result += 1 + 1, 그 다음은 (2)로 만들고 result += 2 + 1 이렇게 하려고 했는데 이리저리 까다로운 부분이 너무 많았다.

결국 한참 고민하다가 다른 사람들의 힘을 빌렸는데 다들 정말 쉽게 풀어서 눈물 날 뻔

케이스를 잘 나눠야겠다는 생각이 번쩍들었다.

이 문제도 케이스만 잘 나눴더라면..

1. ( 이 들어오면 stack에 push 한다.
2. ) 이 들어올 경우 ()인지 ))인지 확인
3. ()이라면 stack에 들어있는 ( 수 만큼 \+
4. ))이라면 한 괄호가 끝난 것 이므로 stack에서 한 (를 pop하고 \+ 1

스택을 쓰면 무조건 스택만으로 해결하려고 했는데 원래 데이터에 접근해서 ()인지, ))인지 확인하는건 생각도 못했다. 다음 문제부턴 원래 데이터 가만히 나둬서 뭐하냐! 적재적소에 잘 써봐야겠다.

`<2493>`

7월 13일 오큰수 풀이에서 사용했던 인덱스 넣었다가 사용하는 방법을 써봤다.

탑들이 [6, 9, 5, 7, 4] 이렇게 있다면 뒤에서 부터 탐색한다.

> 1.  (i = 4) 먼저 4 일때 indexs는 비었으니까 그냥 indexs에 i를 push해준다.
>     indexs = [4]

> 2. (i = 3) 탑의 높이가 7이고 인덱스를 탐색한다. 이때 towers[4] \< towers[3] 을 만족하므로 result[4] = i + 1을 해준다.

이런식으로 반복하면 원하는 답이 나온다. 그런데 완전 탐색을 사용해서 시간초과.. 결국 또 구글의 힘을 빌렸다.
비슷한 로직이지만 이 분은 더 효율적인 코드를 짜셨다. 배울게 너무 많다~~~

---

## 21.07.18 - 실전 문제 풀이

> - [크레인 인형뽑기](https://programmers.co.kr/learn/courses/30/lessons/64061)

`- 2019 카카오 개발자 겨울 인턴쉽 \_ 크레인 인형 뽑기`

처음 봤을 땐 문제가 길어서 낯설 수 있는데 차근차근 읽어보니까 간단한 구현 문제였다.

board가 2차원 배열로 주어진다. 그런데 moves는 열을 기준으로 한다.
그래서 N \* M 크기의 board를 N개의 스택으로 만들어서 moves번째 스택을 확인해볼까? 생각했는데 그건 너무 투머치일 것 같아서 다른 방법을 생각했다.
파이썬이 좋은게 for문이 자유롭다.(?)

```python
for list in board:
   print(list)
```

라고 하면, 화면에 board의 행들이 출력이 된다. 그럼 이어서 생각해보자.
인형 뽑기 기계의 제일 위의 행부터 볼 수 있다면,
기계가 내려올 때 제일 먼저 만나는 인형을 뽑으면 된다.
그러니까 list[move]만 탐색해서, 인형이 있을때까지 찾고 (list[move] != 0) 인형을 뽑는다.

```python
for move in moves:
   for row_board in board:
      if row_board[move -1] != 0: # 인형이 있다면
         stack.append(row_board[move - 1]) # 인형을 뽑아서 stack에 담자.
         row_board[move - 1] = 0 # 이제 row_board[move - 1]에는 인형이 없다
```

그 다음 뽑은 인형들 중에서 연속으로 같은 인형이 두개 나온다면 인형을 빼준다.
처음에는 그럼 똑같은 인형이 2개 이상일때도 다 빼줘야 하는건가? 생각했는데 그럴 일은 일어날 수가 없다. 처음으로 2개가 될 때 그 인형들은 모두 스택에서 나오므로 똑같은 인형이 2개를 넘을 수 없다.

```python
if len(stack) > 1 and stack[-1] == stack[-2]:
   stack.pop()
   stack.pop()
   answer += 2
```

따라서 이런식으로 stack에 들어있는 인형을 검사해주면 된다.

처음에는 moves를 reverse해서 while문을 돌면서 하나씩 pop해주려고 했는데,
그렇게 하면 moves.reverse()할 때 불필요하게 시간을 더 쓰게 된다. 만약에 효율성을 체크하는 문제였다면 감점을 받았지 않을까 생각한다.

그래서 다시 moves를 reverse하지 않고, 처음부터 탐색하는 코드를 짰다.
이게 이전 코드보단 더 효율적인 코드 같다.

---

## 2주차 소감

> 하루도 안 빠지고 다 풀어서 뿌듯하다. 그런데 중간중간 못 풀어서 구글링 한 문제가 있어서 조금 눈물 나지만 뭐 어때 이제 시작인데~ 지금 열심히 구글링 해서 공부하고 진짜 테스트때 완벽하게 다 쓸 수 있길 ㅎㅎ
